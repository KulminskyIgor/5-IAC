# 1. IaC Introduction

## 1.1 Configuration management
### 1.1.1 Before Configuration management

Давайте предствим как создается инфраструктура для проекта, с точки зрения специалиста по конфигурации ПО, или разработчика, которому, например, поручили такое дело в отсуствии специалиста по конфигурации ПО в команде : ему необходимо развернуть приложение и для этого нужен сервер. 

![Before configuration management](../assets/01_06.png?raw=true "Before configuration management")

Он звонит в техподдержку или открывает тикет в системе сервисдеск и просит, что ему нужен новый сервер и учетные данные для подключения к нему. В техподдержке системный администратор получает со склада сервер, распаковывает его, устанавливает в серверную, разворачивает ОС на нем и предоставляет доступ для нашего специалиста. Теперь DevOps инженер может подключиться серверу с только что установленной ОС и начать установку, например пакетов системного и прикладного ПО, нужных версий, (Python, Java, Node, PHP, composer) для сервера приложений, или если это сервер БД, то нужные пакеты для Базы определенной версии,  и вручную скопирует уже имеющиеся конфигурационные файлы на эти сервера. которые необходимы для работы разрабатываемого приложения.

![Before configuration management](../assets/01_07.png?raw=true "Before configuration management")

И в этоге наши сервера превраются в условно говоря, снежинку! Невоспроизводимою, уникальную конфигурацию инфраструктуры, которая при каждом последующем создании будет неповторима. Обьяснить это можно многими причинами, например, человеческим фактором, последующее создание такой инфраструктуры может быть выполнено другим системным администратором, который вроде бы и действует по инструкции, но в силу своей загруженности и мультизадачности, в следующий раз установит ОС с версией немного другой, системное ПО, может быть так же других версий, или вовсе отсутствовать, наш специлист, может не обратить на это внимание, и сам выполнить немного другую последовательность действий в процессе ручной конфигурации ПО. 
CM решает эту проблему со сложностями в воспроизведении конфигурацией.

### 1.1.2 Configuration management

Начнем с небольшого примера, зачем нужен СМ, Например у нас есть в проекте build сервер, с помощью которого мы собираем пакет для последующей установки на STAGE Environment. Пусть это будет веб приложение на PHP  

![Сonfiguration management](../assets/01_19.png?raw=true "Сonfiguration management")
 
Этот сервер во время билда берет код из репозитория проекта, скачивает из интернета зависимости и библиотеки необходимые для нового функционала в проекте, создает архив, который в дальнейшем отправляется на Stage окружение и разворачивается там для финального тестирования перед выходом в продакшон.

![Сonfiguration management](../assets/01_23.png?raw=true "Сonfiguration management")

Однажды выясняется, что нам нужно переехать на новую платформу инфраструктуры, по тем или иным причинам, например для того, чтобы расширить возможности нашего CICD процесса, мы получаем доступ к новой инфраструктуре, решаем переехать. Создаем заново Build-сервер или используем одним из уже имеющихся там расшаренных серверов, с вроде-бы такими же параметрами, 

![Сonfiguration management](../assets/01_25.png?raw=true "Сonfiguration management")

но что-то идет не так. Знания о том, как мы 3 года назад устанавливали наш Build-сервер оказались не документированы, версии установленной OS и необходимых пакетов для Build-сервера не совпали, или некоторые пакеты и вовсе отсуствовали.

И как результат - наш сервер оказался неспособным создать Build 

![Сonfiguration management](../assets/01_26.png?raw=true "Сonfiguration management")

СМ – это про то чтобы обеспечить успешный переезд сервера, про то, чтобы знание о конфигурации сервера было актуально и хранилось в репозитории проекта, как например здесь, в Dockerfile и могло быть воспроизведено бестро и без ошибок.

![Сonfiguration management](../assets/01_27.png?raw=true "Сonfiguration management")

СМ – это про такой процесс, который постоянно повторяется, при внесении изменений в конфигурацию, эти изменения документируются, проверяется, что инфраструктура работает, эти знания накапливаются и изучаются совместно в команде, которая работает над созданием приложения.

![Сonfiguration management](../assets/01_29.png?raw=true "Сonfiguration management")

В целом, под инфраструктурой понимают конфигурационные файлы, необходимые для запуска ПО, запущенные сервисы, правила файервола, для предоставления различных доступов, между серверами разработки, в соответствии с политикой безопасности, так же действующие лицензии на платное ПО. 
Задача СМ сводится к тому, чтобы инфраструктура работала и в команде проекта было понимание как это работает. Скорее всего, конечно, не все участники команды обладают этим пониманием, но все знают где можно ознакомиться с подробностями инфраструктуры, и у кого можно проконсультироваться по поводу конфигурации, внутри команды.

И как результат, в работе СМ, вместо снежинки, которая получилась из серверов, при ручной настройке различными специалистами,

![Сonfiguration management](../assets/01_30.png?raw=true "Сonfiguration management")

У нас получилась воспроизводимая конфигурация. Возможно это будет не быстро и не сразу, мы снова будем звонить в техподдержку, чтобы нам установили сервера в стойки, настроили их, но знание об инфраструктуре о том как настроены сервера, в команде известно и хранится, например в вики и мы можем это воспроизвести.

![Сonfiguration management](../assets/01_31.png?raw=true "Сonfiguration management")

### 1.1.3 Infrastructure as Code (IaC)

Как следующий этап развития в СМ появился запрос о том, что нужно воспроизводить инфраструктуру быстрее, и вопрос: что делать в случае, если нужно срочно переехать в новый дата центр,  при этом имающийся датацентр больше недоступен и нам нужно все построить с нуля.

![Сonfiguration management](../assets/01_32.png?raw=true "Сonfiguration management")

И здесь появляется IaC то есть меняется представление о том где хранится знание об инфраструктуре: вместо вики страниц в конфлюенсе или, еще до них, вместо распечаток в больших папках на стелажах, наше знание перемещается в код, который лежит в репозитории с определенным набором инструментов: ПО, например вместо коллцентра техподдержки используется Тарраформ (мы еще будем о нем говорить подробней позже), настройка сервера производится не вручную, вводом команд через удаленное подключение к серверу, а представляется в виде воспроизводимого кода в Ансибл.

Подводя итог определию СМ, можно сказать, что вместо уникальной конфигураций у нас должна быть воспроизводимая рабочая конфигурация, которую можно контролировать и понимать как она работает.

![Сonfiguration management](../assets/01_33.png?raw=true "Сonfiguration management")

## 1.2 IaC: Vagrant, Packer, Terraform, Ansible
### 1.2.1 IaC Intro

СМ, как мы уже говорили, может работать со звонком в техподдержку в датацентр, для того, чтобы нам помогли настроить сервер, и так же может работать, при помощи набора ПО, которое может ускорить управление серверами в датацетре и представить конфигурацию в виде кода.
В обоих вариантах СМ отвечает на вопрос:

![Сonfiguration management](../assets/01_36.png?raw=true "Сonfiguration management")

Как бороться с беспорядком? Как привести инфраструктуру, к тому, чтобы она была воспроизводима.

![Сonfiguration management](../assets/01_41.png?raw=true "Сonfiguration management")

Знание о том, как устроена инфраструктура может храниться в виде тасок в Джире и Вики страниц в конфлюенсе, но 
Тут надо понимать, как это знание, построенное отдельно от самой инфраструктуры, соотносится с тем, что реально происходит в действительности, т.е. на самих серверах, действительно, ли то что описано в вики, применено на серверах сейчас, в данный момент времени, а не на момент написания страницы в вики, или на момет закрытия задачи в джире. Для гротеска, еще можно вспомнить бумажный докментооборот, на предоставление доступа и согласование конфигураций с подписями и печатями, между подразделениями, который еще можно встретить, и сейчас, как основной способ ведения документации во многих крупных компаниях.
В варианте описания инфраструктуры в виде кода, как в правой части слайда, хранящегося в репозитории проекта, нам не нужно беспокоиться об
актуальности этого знания, мы точно уверены, что именно эти версии джавы и БД установлены, для определенной версии приложения в настойщий момент. Нам не нужно специально вручную подключаться к серверам, для того, чтобы в этом убедиться. Конечно для этого у нас должен быть настроен IaC, с помощью специальных инструментов

![Сonfiguration management](../assets/01_42.png?raw=true "Сonfiguration management")

Надо понимать, что инфраструктура описанная с помощью кода, т.е. конфигурационые файлы написанные в разных инструментах и размещенные в репозитории, сами по себе не обеспечат, и не заменят традиционный СМ, необходимо приложить определенное время и силы, для того, чтобы IaC заработал эффективно. О том как это сделать, расскажет Лев в 5 и 6 темах – это будет в следующее занятие, в понедельник. Так же мы говорим об этом в нашем дополнительном, углубленном курсе по Ансибл, разработанный Львом Гончаровым, дающий практические навыки работы с А, как одного из инструментов IaC.

### 1.2.2 IaC use cases

Рассмортим пример, как используется IaC в реальной жизни в проекте

![Сonfiguration management](../assets/01_52.png?raw=true "Сonfiguration management")

Например, в проекте уже есть сервера, при помощи подхода IaC, Можно описать их конфигурацию в виде кода, который размещен в репозитории проекта в гите, в этом случае, если после применения новых конфигурационных файлов, что-то пошло не так, можно вернуться к предыдущей версии файлов в репозитории и восстановить работу окружения для разработки на серверах. При этом не нужно вручную подключаться к каждому серверу и раскоментировать старые резервные копии конфигурационных файлов.
Так же, с помощью IaC можно создавать и вносить изменения в конфигурацию самих виртуальных машин, например, быстро, целиком пересоздать окружение, начать, снова с чистой ОС и виртального диска без лишней врЕменной или созданной по ошибке структуры файлов. 
Еще с помощью IaC можно создавать эталонные шаблоны ВМ, в которые включено все необходимое для развертывания ВМ с разрабатываемым приложением, и как вариант, предоставить такой шаблон для разворачивания у клиента, или для быстрого включения в работу нового разработчика, которому не нужно самостоятельно, по инструкции на вики устанавливать все необходимое для рабочего окружения.
C другой стороны, установка приложения с помощью IaC поможет операционной команде быть ближе к разработчикам, в варианте, когда конфигурация хранится в репозитории доступном обеим командам, т.к. разработчики лучше знают какие версии пакетов и библиотек необходимы для работы приложения, в какие конфигурационные файлы нужно внести изменения, а операционная команда должна, например, в кратчайшие сроки восстановить работоспособность приложения, в случае, возникновения проблемы, в том числе, путем пересоздания окружения, т.е. развернуть ВМ, ОС, необходимые системные пакеты и само приложение.

### 1.2.3 IaC tooling: Vagrant, Packer, Terraform, Ansible

давайте перейдем к теме инструментов в IaC. И перечислим задачи которые выполняет CM.
Шаблонизирование или темплейтинг инфраструктуры. Здесь подразумевается создание шаблона виртуальной машины, или имиджа контейнера, из которого будет развернут контейнер.
Созданные имиджи на первом шаге можно развернуть в облаке, т.е. из шаблона виртуальной машины запустить новую виртуальную машину в инфраструктуре облачного провайдера или развернуть приложение в системе оркестрации контейнеров
Далее, когда инфраструктура в виде виртуальных машин или контейнеров готова, становится возможна установка разрабатываемого или тестируемого приложения
и его конфигурация. эти четрые задачи можно выполнить разными инструментами, например,

![Сonfiguration management](../assets/01_59.png?raw=true "Сonfiguration management")

Есть такие утилиты как : puppet, saltstack, chef и A, которые закрывают большую часть представленного на слайде стека задач. С помощью их мы можем создать ВМ, внести изменения в конфигурацию ОС, например, изменить тайм зону, создать пользователя, от имени созданного пользователя установить необходимое ПО для работы разрабатываемого приложения и установить само приложение. Эти утилиты так или иначе одинаковы по своей архитектуре, разницу можно увидеть в Pull или Push модели

### 1.3 Immutable infrastructure

### 1.4 Training environment
